mod engine;
mod config;

use engine::ArbitrageEngine;
use std::sync::Arc;
use strategy::{
    context::StrategyContext,
    market_state::MarketState,
    min_profit::MinProfitModel,
    plugins::inter_exchange::InterExchangeStrategy,
    plugins::triangular::{TriangularStrategy, DynamicTriangularStrategy},
    traits::ArbitrageStrategy,
    FeePrecisionRepoImpl,
};
use crate::config::SystemConfig;
use adapters::{nats::NatsAdapter, nats::NatsMessage};
use std::sync::atomic::{AtomicU64, Ordering};
use tracing_subscriber::EnvFilter;
use parking_lot::RwLock;
use std::collections::HashMap;
use serde_json;
use metrics::gauge;
use common::market_data::NormalizedSnapshot;

/// å¸‚åœºæ•°æ®å¤„ç†å™¨ - åè°ƒå™¨æ ¸å¿ƒç»„ä»¶1
struct MarketDataProcessor {
    engine: Arc<ArbitrageEngine>,
    processed_count: AtomicU64,
    opportunity_count: AtomicU64,
}

impl MarketDataProcessor {
    fn new(engine: Arc<ArbitrageEngine>) -> Self {
        Self {
            engine,
            processed_count: AtomicU64::new(0),
            opportunity_count: AtomicU64::new(0),
        }
    }

    async fn process_market_data(&self, data: Vec<u8>) -> anyhow::Result<()> {
        let count = self.processed_count.fetch_add(1, Ordering::Relaxed);
        
        // é«˜é¢‘æ•°æ®å¤„ç†ç»Ÿè®¡
        if count % 10000 == 0 {
            tracing::info!("åè°ƒå™¨å·²å¤„ç† {} æ¡å¸‚åœºæ•°æ®", count);
        }

        // è§£æå¸‚åœºæ•°æ®
        let market_snapshot: NormalizedSnapshot = serde_json::from_slice(&data)
            .map_err(|e| anyhow::anyhow!("å¸‚åœºæ•°æ®è§£æå¤±è´¥: {}", e))?;

        // é€šè¿‡å¼•æ“å¤„ç†å¿«ç…§ - å¤šç­–ç•¥å¹¶è¡Œæ£€æµ‹
        let opportunities = self.engine.process_snapshot(&market_snapshot);
        
        if !opportunities.is_empty() {
            let opp_count = self.opportunity_count.fetch_add(opportunities.len() as u64, Ordering::Relaxed);
            tracing::info!("åè°ƒå™¨æ£€æµ‹åˆ° {} ä¸ªå¥—åˆ©æœºä¼š (æ€»è®¡: {})", opportunities.len(), opp_count);
            
            // è¿™é‡Œåº”è¯¥è§¦å‘æ‰§è¡Œé“¾è·¯
            for opp in opportunities {
                tracing::info!("ğŸ¯ å¥—åˆ©æœºä¼š: {} -> {}, åˆ©æ¶¦: {:.6}%", 
                    opp.legs.get(0).map(|l| l.exchange.as_str()).unwrap_or("Unknown"), opp.legs.get(1).map(|l| l.exchange.as_str()).unwrap_or("Unknown"), opp.net_profit_pct.to_f64() * 100.0);
                // TODO: å®é™…æ‰§è¡Œå¥—åˆ©
            }
        }

        Ok(())
    }
}

/// é…ç½®çƒ­é‡è½½å¤„ç†å™¨ - åè°ƒå™¨æ ¸å¿ƒç»„ä»¶2
struct ConfigurationManager {
    fee_repo: Arc<FeePrecisionRepoImpl>,
    min_profit_model: Arc<MinProfitModel>,
    reload_count: AtomicU64,
}

impl ConfigurationManager {
    fn new(fee_repo: Arc<FeePrecisionRepoImpl>, min_profit_model: Arc<MinProfitModel>) -> Self {
        Self { 
            fee_repo, 
            min_profit_model,
            reload_count: AtomicU64::new(0),
        }
    }

    async fn handle_config_update(&self, config_type: String, data: Vec<u8>) -> anyhow::Result<()> {
        let count = self.reload_count.fetch_add(1, Ordering::Relaxed);
        
        match config_type.as_str() {
            "fee_precision" => {
                tracing::info!("ğŸ”„ åè°ƒå™¨çƒ­é‡è½½æ‰‹ç»­è´¹ç²¾åº¦é…ç½® (ç¬¬{}æ¬¡)", count);
                // TODO: å®ç°åŠ¨æ€æ‰‹ç»­è´¹æ›´æ–°
                Ok(())
            }
            "min_profit" => {
                tracing::info!("ğŸ”„ åè°ƒå™¨çƒ­é‡è½½æœ€å°åˆ©æ¶¦æ¨¡å‹ (ç¬¬{}æ¬¡)", count);
                // TODO: å®ç°æœ€å°åˆ©æ¶¦æ¨¡å‹åŠ¨æ€æ›´æ–°
                Ok(())
            }
            "strategy_params" => {
                tracing::info!("ğŸ”„ åè°ƒå™¨çƒ­é‡è½½ç­–ç•¥å‚æ•° (ç¬¬{}æ¬¡)", count);
                // TODO: å®ç°ç­–ç•¥å‚æ•°åŠ¨æ€æ›´æ–°
                Ok(())
            }
            _ => {
                tracing::warn!("âš ï¸ åè°ƒå™¨æ”¶åˆ°æœªçŸ¥é…ç½®ç±»å‹: {}", config_type);
                Ok(())
            }
        }
    }
}

/// ç³»ç»ŸçŠ¶æ€ç›‘æ§å™¨ - åè°ƒå™¨æ ¸å¿ƒç»„ä»¶3  
struct SystemMonitor {
    engine: Arc<ArbitrageEngine>,
    start_time: std::time::Instant,
    status_published: AtomicU64,
}

impl SystemMonitor {
    fn new(engine: Arc<ArbitrageEngine>) -> Self {
        Self {
            engine,
            start_time: std::time::Instant::now(),
            status_published: AtomicU64::new(0),
        }
    }

    async fn get_system_status(&self) -> serde_json::Value {
        let uptime = self.start_time.elapsed().as_secs();
        let status_count = self.status_published.fetch_add(1, Ordering::Relaxed);
        
        serde_json::json!({
            "orchestrator_status": "operational",
            "uptime_seconds": uptime,
            "status_reports_sent": status_count,
            "strategy_engine": {
                "inter_exchange_slippage_pct": self.engine.context.inter_exchange_slippage_per_leg_pct,
                "inter_exchange_min_liquidity_usd": self.engine.context.inter_exchange_min_liquidity_usd,
                "market_state": format!("{:?}", self.engine.context.get_market_state()),
            },
            "active_strategies": [
                "InterExchangeStrategy",      // è·¨äº¤æ˜“æ‰€å¥—åˆ©
                "DynamicTriangularStrategy",  // v3.0ä¸‰è§’å¥—åˆ©
                "TriangularStrategy"          // å‘åå…¼å®¹
            ],
            "orchestrator_components": {
                "market_data_processor": "active",
                "configuration_manager": "active", 
                "system_monitor": "active",
                "risk_controller": "active"
            }
        })
    }
}

/// é£é™©æ§åˆ¶å™¨ - åè°ƒå™¨æ ¸å¿ƒç»„ä»¶4
struct RiskController {
    daily_pnl: RwLock<f64>,
    position_limits: RwLock<HashMap<String, f64>>,
    risk_checks: AtomicU64,
}

impl RiskController {
    fn new() -> Self {
        Self {
            daily_pnl: RwLock::new(0.0),
            position_limits: RwLock::new(HashMap::new()),
            risk_checks: AtomicU64::new(0),
        }
    }

    async fn perform_risk_check(&self) -> anyhow::Result<bool> {
        let check_count = self.risk_checks.fetch_add(1, Ordering::Relaxed);
        
        if check_count % 1000 == 0 {
            tracing::debug!("ğŸ›¡ï¸ åè°ƒå™¨æ‰§è¡Œç¬¬{}æ¬¡é£é™©æ£€æŸ¥", check_count);
        }

        let daily_pnl = *self.daily_pnl.read();
        
        // é£é™©é™åˆ¶æ£€æŸ¥
        if daily_pnl < -50000.0 { // $50K æ—¥äºæŸé™åˆ¶
            tracing::error!("ğŸš¨ åè°ƒå™¨æ£€æµ‹åˆ°æ—¥äºæŸè¶…é™: ${:.2}", daily_pnl);
            return Ok(false);
        }

        Ok(true)
    }

    fn update_pnl(&self, pnl_change: f64) {
        let mut daily_pnl = self.daily_pnl.write();
        *daily_pnl += pnl_change;
        gauge!("orchestrator_daily_pnl", *daily_pnl);
    }
}

/// CELUEé«˜é¢‘å¥—åˆ©åè°ƒå™¨ - ç³»ç»Ÿæ ¸å¿ƒ
struct CelueOrchestrator {
    // æ ¸å¿ƒå¼•æ“
    engine: Arc<ArbitrageEngine>,
    
    // å¤–éƒ¨é€‚é…å™¨
    nats_adapter: NatsAdapter,
    
    // åè°ƒå™¨æ ¸å¿ƒç»„ä»¶
    market_data_processor: MarketDataProcessor,
    configuration_manager: ConfigurationManager,
    system_monitor: SystemMonitor,
    risk_controller: RiskController,
}

impl CelueOrchestrator {
    async fn new(system_config: SystemConfig) -> anyhow::Result<Self> {
        tracing::info!("ğŸš€ åˆå§‹åŒ–CELUEé«˜é¢‘å¥—åˆ©åè°ƒå™¨");

        // åˆå§‹åŒ–NATSé€‚é…å™¨
        let nats_config = system_config.nats.clone();
        let nats_adapter = NatsAdapter::new()
            .map_err(|e| anyhow::anyhow!("NATSé€‚é…å™¨åˆå§‹åŒ–å¤±è´¥: {}", e))?;

        // åˆå§‹åŒ–æœ€å°åˆ©æ¶¦æ¨¡å‹
        let min_profit_model = Arc::new(MinProfitModel::new(
            (system_config.strategy.min_profit_threshold * 10000.0) as u32,
            system_config.strategy.market_state.cautious_weight,
            system_config.strategy.market_state.extreme_weight,
        ));

        // åˆå§‹åŒ–æ‰‹ç»­è´¹ç²¾åº¦ä»“åº“
        let fee_precision_repo = Arc::new(FeePrecisionRepoImpl::default());

        // åˆ›å»ºç­–ç•¥ä¸Šä¸‹æ–‡
        let metrics = Arc::new(adapters::metrics::AdapterMetrics::new());
        let ctx = StrategyContext::new(fee_precision_repo.clone(), metrics);

        // åˆå§‹åŒ–ç­–ç•¥é›†åˆ - åè°ƒå™¨ç®¡ç†å¤šç§ç­–ç•¥
        let mut strategies: Vec<Box<dyn ArbitrageStrategy>> = Vec::new();
        
        tracing::info!("ğŸ“‹ åè°ƒå™¨æ³¨å†Œç­–ç•¥:");
        
        // æ³¨å†Œè·¨äº¤æ˜“æ‰€å¥—åˆ©ç­–ç•¥
        strategies.push(Box::new(InterExchangeStrategy));
        tracing::info!("  âœ… InterExchangeStrategy (è·¨äº¤æ˜“æ‰€å¥—åˆ©)");
        
        // æ³¨å†Œv3.0åŠ¨æ€ä¸‰è§’å¥—åˆ©ç­–ç•¥
        strategies.push(Box::new(DynamicTriangularStrategy::new()));
        tracing::info!("  âœ… DynamicTriangularStrategy (v3.0ä¸‰è§’å¥—åˆ©)");
        
        // æ³¨å†Œå‘åå…¼å®¹ä¸‰è§’å¥—åˆ©ç­–ç•¥
        strategies.push(Box::new(TriangularStrategy));
        tracing::info!("  âœ… TriangularStrategy (å‘åå…¼å®¹)");

        // åˆ›å»ºå¥—åˆ©å¼•æ“
        let engine = Arc::new(ArbitrageEngine::new(strategies, ctx));

        // åˆå§‹åŒ–åè°ƒå™¨æ ¸å¿ƒç»„ä»¶
        let market_data_processor = MarketDataProcessor::new(engine.clone());
        let configuration_manager = ConfigurationManager::new(fee_precision_repo, min_profit_model);
        let system_monitor = SystemMonitor::new(engine.clone());
        let risk_controller = RiskController::new();

        tracing::info!("ğŸ¯ åè°ƒå™¨æ ¸å¿ƒç»„ä»¶åˆå§‹åŒ–å®Œæˆ");

        Ok(Self {
            engine,
            nats_adapter,
            market_data_processor,
            configuration_manager,
            system_monitor,
            risk_controller,
        })
    }

    async fn start(&mut self) -> anyhow::Result<()> {
        tracing::info!("ğŸª å¯åŠ¨CELUEé«˜é¢‘å¥—åˆ©åè°ƒå™¨");

        // è¿æ¥NATS
        self.nats_adapter.connect().await
            .map_err(|e| anyhow::anyhow!("NATSè¿æ¥å¤±è´¥: {}", e))?;

        // è®¢é˜…å¸‚åœºæ•°æ®æµ - åè°ƒå™¨æ ¸å¿ƒåŠŸèƒ½1
        let processor = &self.market_data_processor;
        // TODO: é‡æ–°è®¾è®¡ NATS è®¢é˜…æ¥å£
        // self.nats_adapter.subscribe("market.data.normalized").await

        // è®¢é˜…é…ç½®æ›´æ–°æµ - åè°ƒå™¨æ ¸å¿ƒåŠŸèƒ½2
        let config_mgr = &self.configuration_manager;
        // TODO: é‡æ–°è®¾è®¡ NATS è®¢é˜…æ¥å£
        // self.nats_adapter.subscribe("market.data.normalized").await

        // å¯åŠ¨ç³»ç»Ÿç›‘æ§ - åè°ƒå™¨æ ¸å¿ƒåŠŸèƒ½3
        self.start_system_monitoring().await?;

        // å¯åŠ¨é£é™©æ§åˆ¶ - åè°ƒå™¨æ ¸å¿ƒåŠŸèƒ½4
        self.start_risk_monitoring().await?;

        // å¯åŠ¨ä¸»äº‹ä»¶å¾ªç¯
        self.run_main_loop().await
    }

    async fn start_system_monitoring(&self) -> anyhow::Result<()> {
        let monitor = &self.system_monitor;
        let nats = &self.nats_adapter;
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(std::time::Duration::from_secs(30));
            
            loop {
                interval.tick().await;
                
                let status = monitor.get_system_status().await;
                if let Ok(status_bytes) = serde_json::to_vec(&status) {
                    if let Err(e) = nats.publish("orchestrator.status", &adapters::nats::NatsMessage { subject: "orchestrator.status".to_string(), payload: status_bytes }).await {
                        tracing::error!("åè°ƒå™¨çŠ¶æ€å‘å¸ƒå¤±è´¥: {}", e);
                    }
                }
            }
        });
        
        tracing::info!("ğŸ“Š åè°ƒå™¨ç³»ç»Ÿç›‘æ§å·²å¯åŠ¨");
        Ok(())
    }

    async fn start_risk_monitoring(&self) -> anyhow::Result<()> {
        let risk_controller = &self.risk_controller;
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(std::time::Duration::from_secs(5));
            
            loop {
                interval.tick().await;
                
                if let Err(e) = risk_controller.perform_risk_check().await {
                    tracing::error!("åè°ƒå™¨é£é™©æ£€æŸ¥å¤±è´¥: {}", e);
                } else if !risk_controller.perform_risk_check().await.unwrap_or(true) {
                    tracing::warn!("ğŸš¨ åè°ƒå™¨è§¦å‘é£é™©æ§åˆ¶ï¼Œå»ºè®®æš‚åœäº¤æ˜“");
                }
            }
        });
        
        tracing::info!("ğŸ›¡ï¸ åè°ƒå™¨é£é™©ç›‘æ§å·²å¯åŠ¨");
        Ok(())
    }

    async fn run_main_loop(&self) -> anyhow::Result<()> {
        tracing::info!("ğŸ”„ åè°ƒå™¨è¿›å…¥ä¸»äº‹ä»¶å¾ªç¯");
        
        // ç­‰å¾…ç»ˆæ­¢ä¿¡å·
        let mut sigterm = tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())?;
        let mut sigint = tokio::signal::unix::signal(tokio::signal::unix::SignalKind::interrupt())?;
        
        tokio::select! {
            _ = sigterm.recv() => {
                tracing::info!("ğŸ“¨ åè°ƒå™¨æ”¶åˆ°SIGTERMä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­");
            }
            _ = sigint.recv() => {
                tracing::info!("ğŸ“¨ åè°ƒå™¨æ”¶åˆ°SIGINTä¿¡å·ï¼Œå¼€å§‹ä¼˜é›…å…³é—­");
            }
        }
        
        // ä¼˜é›…å…³é—­
        self.graceful_shutdown().await?;
        Ok(())
    }

    async fn graceful_shutdown(&self) -> anyhow::Result<()> {
        tracing::info!("ğŸ›‘ åè°ƒå™¨å¼€å§‹ä¼˜é›…å…³é—­æµç¨‹");
        
        // æ–­å¼€NATSè¿æ¥
        if let Err(e) = self.nats_adapter.disconnect().await {
            tracing::error!("åè°ƒå™¨NATSæ–­å¼€å¤±è´¥: {}", e);
        }
        
        tracing::info!("âœ… CELUEé«˜é¢‘å¥—åˆ©åè°ƒå™¨å·²å®Œæˆå…³é—­");
        Ok(())
    }
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .with_target(false)
        .with_thread_ids(true)
        .with_level(true)
        .init();

    tracing::info!("ğŸ­ å¯åŠ¨CELUEé«˜é¢‘å¥—åˆ©åè°ƒå™¨");
    tracing::info!("ğŸ—ï¸ åè°ƒå™¨æ¶æ„: å¤šç­–ç•¥ç»Ÿä¸€ç®¡ç† + ç³»ç»Ÿçº§åè°ƒ");

    // åŠ è½½ç³»ç»Ÿé…ç½®
    let system_config = SystemConfig::from_file("config/orchestrator_config.toml")
        .map_err(|e| anyhow::anyhow!("åŠ è½½ç³»ç»Ÿé…ç½®å¤±è´¥: {}", e))?;

    // åˆ›å»ºå¹¶å¯åŠ¨åè°ƒå™¨
    let mut orchestrator = CelueOrchestrator::new(system_config).await
        .map_err(|e| anyhow::anyhow!("åˆ›å»ºåè°ƒå™¨å¤±è´¥: {}", e))?;

    // å¯åŠ¨åè°ƒå™¨ä¸»å¾ªç¯
    orchestrator.start().await
        .map_err(|e| anyhow::anyhow!("å¯åŠ¨åè°ƒå™¨å¤±è´¥: {}", e))?;

    Ok(())
}
