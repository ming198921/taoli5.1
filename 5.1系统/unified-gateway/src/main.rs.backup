use axum::{
    extract::{Path, WebSocketUpgrade},
    http::{Method, StatusCode},
    response::{Json, Response},
    routing::{any, get, post},
    Router,
};
use serde_json::{json, Value};
use std::collections::HashMap;
use tokio::net::TcpListener;
use tower_http::cors::CorsLayer;
use tracing::{info, warn};

mod system_control;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt()
        .with_env_filter("unified_gateway=info")
        .init();

    info!("ðŸš€ Starting Unified Gateway v1.0.0");
    info!("ðŸŒ Routing 387 APIs across 7 microservices");

    let app = Router::new()
        .route("/health", get(health_check))
        .route("/status", get(gateway_status))
        
        // === ç³»ç»ŸæŽ§åˆ¶API ===
        .route("/api/system/start", post(system_control::system_start))
        .route("/api/system/stop", post(system_control::system_stop))
        .route("/api/system/restart", post(system_control::system_restart))
        .route("/api/system/emergency-stop", post(system_control::emergency_stop))
        .route("/api/system/force-shutdown", post(system_control::force_shutdown))
        .route("/api/system/graceful-shutdown", post(system_control::graceful_shutdown))
        .route("/api/system/services/restart", post(system_control::restart_all_services))
        .route("/api/system/services/:service/restart", post(system_control::restart_service))
        .route("/api/system/services/:service/start", post(system_control::start_service))
        .route("/api/system/services/:service/stop", post(system_control::stop_service))
        .route("/api/system/maintenance/enable", post(system_control::enable_maintenance_mode))
        .route("/api/system/maintenance/disable", post(system_control::disable_maintenance_mode))
        .route("/api/system/backup/create", post(system_control::create_system_backup))
        .route("/api/system/backup/restore", post(system_control::restore_system_backup))
        .route("/api/system/diagnostics/run", post(system_control::run_system_diagnostics))
        .route("/api/system/health/deep-check", get(system_control::deep_health_check))
        
        // WebSocketå‡çº§ç«¯ç‚¹
        .route("/ws/system/monitor", get(system_control::websocket_system_monitor))
        .route("/ws/system/logs", get(system_control::websocket_system_logs))
        
        // é€šç”¨ä»£ç†è·¯ç”±
        .route("/api/*path", any(proxy_handler))
        .layer(CorsLayer::permissive());

    let listener = TcpListener::bind("0.0.0.0:3000").await?;
    info!("âš™ï¸ Unified Gateway listening on http://0.0.0.0:3000");
    info!("âœ… Gateway initialized - routing to 7 microservices");

    axum::serve(listener, app).await?;
    Ok(())
}

async fn health_check() -> Json<Value> {
    Json(json!({
        "status": "healthy",
        "service": "unified-gateway",
        "version": "1.0.0",
        "timestamp": chrono::Utc::now(),
        "microservices": 7,
        "total_apis": 387
    }))
}

async fn gateway_status() -> Json<Value> {
    let services = vec![
        ("logging-service", "4001", 45),
        ("cleaning-service", "4002", 52), 
        ("strategy-service", "4003", 38),
        ("performance-service", "4004", 67),
        ("trading-service", "4005", 41),
        ("ai-model-service", "4006", 48),
        ("config-service", "4007", 96),
    ];

    let mut service_status = HashMap::new();
    let mut total_healthy = 0;

    for (name, port, apis) in &services {
        let url = format!("http://localhost:{}/health", port);
        let status = match reqwest::get(&url).await {
            Ok(response) if response.status().is_success() => {
                total_healthy += 1;
                "healthy"
            }
            _ => "unhealthy"
        };
        
        service_status.insert(*name, json!({
            "port": port,
            "apis": apis,
            "status": status
        }));
    }

    Json(json!({
        "gateway_status": "operational",
        "total_services": services.len(),
        "healthy_services": total_healthy,
        "total_apis": 387,
        "services": service_status,
        "timestamp": chrono::Utc::now()
    }))
}

async fn proxy_handler(
    method: Method,
    Path(path): Path<String>,
    body: String,
) -> Result<Json<Value>, StatusCode> {
    // æ ¹æ®è·¯å¾„è·¯ç”±åˆ°å¯¹åº”çš„å¾®æœåŠ¡
    let (service_port, service_name) = match path.as_str() {
        p if p.starts_with("logs") || p.starts_with("logs/") => ("4001", "logging-service"),
        p if p.starts_with("cleaning") || p.starts_with("cleaning/") => ("4002", "cleaning-service"),
        p if p.starts_with("strategy") || p.starts_with("strategy/") => ("4003", "strategy-service"),
        p if p.starts_with("performance") || p.starts_with("performance/") => ("4004", "performance-service"),
        p if p.starts_with("orders") || p.starts_with("positions") || p.starts_with("funds") || p.starts_with("risk") => ("4005", "trading-service"),
        p if p.starts_with("models") || p.starts_with("training") || p.starts_with("inference") => ("4006", "ai-model-service"),
        p if p.starts_with("config") || p.starts_with("config/") => ("4007", "config-service"),
        _ => return Err(StatusCode::NOT_FOUND),
    };

    let target_url = format!("http://localhost:{}/api/{}", service_port, path);
    
    // è½¬å‘è¯·æ±‚åˆ°ç›®æ ‡å¾®æœåŠ¡
    let client = reqwest::Client::new();
    let request = match method {
        Method::GET => client.get(&target_url),
        Method::POST => client.post(&target_url).body(body),
        Method::PUT => client.put(&target_url).body(body),
        Method::DELETE => client.delete(&target_url),
        _ => return Err(StatusCode::METHOD_NOT_ALLOWED),
    };

    match request.send().await {
        Ok(response) => {
            let status = response.status();
            match response.json::<Value>().await {
                Ok(json_body) => Ok(Json(json_body)),
                Err(_) => Err(StatusCode::from_u16(status.as_u16()).unwrap_or(StatusCode::INTERNAL_SERVER_ERROR)),
            }
        }
        Err(_) => {
            warn!("Failed to proxy request to {}", service_name);
            Err(StatusCode::BAD_GATEWAY)
        }
    }
}
